# Workshop
the purpose of this workshop is to do a walkthrough of my code on my project Basic DAO in UMOJA Bounty HACK II. In simple terms, Basic DAO means a basic Decentralized Autonomous Organization. that is an organisation where decision-making is not central, instead the member of the organisation (also called DAO) is solely in charge of decsion making mostly by voting. For my project, votes are being cast on which particular idea should the DAO fund, the idea with the highest vote receives the funds once the result is in. Do you want to know how I was able to achieve this the obstacle faced and all? You can through my <a href="https://medium.com/@Ibkodus116/basic-dao-umoja-iii-bounty-hack-team-56-a3bf972b384d" target="_blank">article</a>.

# Requirement
## These are the Basic Requirements/knowledge you are expected to have before going through this workshop.

- At least intermediate knowledge of Web development
- Basic knowledge of Javascript
- Basic knowledge of React
- Go through the Reach tutorial [here](https://docs.reach.sh/tut/rps/#tut)
- Download and Install Reach [here](https://docs.reach.sh/quickstart/#quickstart)

Reach has a very supportive and ready-to-help community if you ever get stocked just put up the question and you will definitely get an answer. Join Reach [Dicord Server](https://discord.com/invite/XJHFzSsc) now.

# Particiapants Activities
although we are not limited to a number of users, due to the limited time available, I made use of 5 participants namely Deployer, Proposer, Initial Investor, Investor 2, and Investor 3, two participants proposes ideas to be voted on while the other 3 participants are a member of the DAO who votes for the best idea. their Activities are:

- Deployer: This is the participant who initiates the protocol and proposes the first idea.

- Proposer: This participant follows suit and proposes the next Idea using the contract ID generated by the deployer.

- Initial Investor: this is the first member of the DAO that saw it fit to vote for that particular idea, this participant selects a specific idea to vote on by using their contract ID, casts their vote and then decides the amount to be used in funding the idea.

- Investor 2: This participant also does the same as the initial investor, but will only need the contract address after which they cast their vote.

- Investor 3: This participant also does the same as investor 2 and casts their vote.

After the whole casting of vote, they will be an alert from the browser showing the idea with the highest vote and funds are sent to the participant who proposed the idea.

# Code Process

## Boostrapping React
to get started on react run this command in your preferred location on your computer
```
npx create-react-app basic-dao
```
wait for the command to run this will bootstrap a react template for you. Next, navigate to the src directory in the terminal this is where we will be writing our reach code.
## Reach Setup
To be sure you have reach installed and working fine run the command below if not check the [Requirement](#requirement) section to learn how

```
reach version
```

On my PC, I get reach 0.1 as the result of that command, if you are getting a message saying Reach is not installed and you are certain you have installed reach by following the instructions in the earlier paragraph. You can follow the steps below to add Reach to your Path on a Windows

1. Open up the Terminal.
2. Run the following command: sudo nano /etc/paths.
3. Enter your password, when prompted.
4. Go to the bottom of the file, and enter /Users/{username}/reach.
5. Hit control-x to quit.
6. Enter “Y” to save the modified buffer. Please note that you might need to close and open all instances of the terminal for this to work well

## Reach Coding
We are making use of VS code so right in vs code in the src folder, please create a new file called index.rsh, this is the file we will be writing our reach code, let's jump right into that:
```
'reach 0.1';
```
this will be our first line of code in the index.rsh file, this simply signifies that this particular file is a reach file and it specifies the version of reach we are currently using. then we create an interface for our basic interaction which will in turn interact with the Front end:


!!!
```js
const Persons = {
  informTimeout: Fun([], Null),
  viewIdeas:  Fun([Bytes(10), Bytes(10)], Null),
  voteIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
}
```

now we proceed to implement the logic of our Reach file, all reach programs have the main function they export, this is what mine looks like below:
```js
export const main = Reach.App(() => {
  exit();
  })
```
the main function that's exported is simply the function returned from the function call of `Reach.App()`, this is where our app logic will live. the other codes I will be writing will live within this function.

Now let's define the interface for responsibilities that are particular to each participant:

below is the interface for the [initial investor](#particiapants-activities)
```js
const user1 = Participant("user1", {
  ...Persons,
  funds: UInt,
  deadline: UInt,

});
```

below is the interface for [investor 2](#particiapants-activities)
```js
const user2 = Participant("user2", {
  ...Persons,
  accepFunds: Fun([UInt], Null),
})
```

below is the interface for [Investor 3](#particiapants-activities)
```js
const user3 = Participant("user3", {
  ...Persons,
  accepFunds: Fun([UInt], Null),
});
```
Below is the interface for the [deployer](#particiapants-activities)
```js
const Proposer1 = Participant("Proposer1", {
  proposeIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
});
```

Below is the interface for the [proposer](#particiapants-activities)

```js
const Proposer2 = Participant("Proposer2", {
  proposeIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
})
```
The three investors (initial investor, investor 2 and Investor 3)inherit all the attributes from `Persons` created earlier. Both the deployer and the proposer were allocated 10 Byte memory space which means they're limited to 10 characters.

!!!
```js
const informTimeout = () => {
  each([user1, user2, user3], ()=> {
    interact.informTimeout();
  })
};
```

!!!
```js
const seeOutcome = (fVote, sVote, tVote) => {
  each([user1, user2, user3, Proposer1, Proposer2], ()=> {
    interact.seeOutcome(fVote, sVote, tVote);
  })
};
```
At this point, we are accepting the idea from the Deployer which the first proposal

```js
Proposer1.only(() => {
  const idea1 = declassify(interact.proposeIdea());
});
Proposer1.publish(idea1);

commit();
```
At this point, we are accepting the idea from the proposer which the second proposal

```js
Proposer2.only(() => {
  const idea2 = declassify(interact.proposeIdea());
})

Proposer2.publish(idea2);

commit();
```
After accepting both proposals we now have two ideas in the contract that are about to be voted for, what we need to do next is to pay token into the contract in other to vote.

This is for user 1 i.e the initial investor we will be giving this user the ability to input a specific amount he wants to pay into the contract. We make sure we keep track of this user vote and also send funds to the contract wallet so their vote can also be cast.
```js
user1.only(()=> {
  const funds = declassify(interact.funds);
  const deadline = declassify(interact.deadline)
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote1 = declassify(interact.voteIdea());
  assume(vote1 == idea1 || vote1 ==idea2)
  assert(vote1 == idea1 || vote1 ==idea2);
});

  user1.publish(funds, deadline, vote1);
  require(vote1 == idea1 || vote1 ==idea2 );
  commit();
  user1.pay(funds)
  commit();
```

This is for user2 i.e investor 2 we keep track of this user vote and make sure we keep track of this user vote and also send funds to the contract wallet so their vote can also be cast.
```js
user2.only(()=> {
  interact.accepFunds(funds);
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote2 = declassify(interact.voteIdea());
  assume(vote2 == idea1 || vote2 ==idea2);
  assert(vote2 == idea1 || vote2 ==idea2);
});

user2.publish(vote2);
require(vote2 == idea1 || vote2 == idea2)
commit();
user2.pay(funds)
  .timeout(relativeTime(deadline), () => closeTo(user1, informTimeout));
  commit();
user2.publish();
commit();
```

This is for user3 i.e investor 3 we keep track of this user vote and make sure we keep track of this user vote and also send funds to the contract wallet so their vote can also be cast.
```js
user3.only(()=> {
  interact.accepFunds(funds);
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote3 = declassify(interact.voteIdea());
  assume(vote3 == idea1 || vote3 == idea2);
  assert(vote3 == idea1 || vote3 == idea2);
});

user3.pay(funds)
  .timeout(relativeTime(deadline), () => closeTo(user1, informTimeout));
  commit();
user3.publish(vote3);
require(vote3 == idea1 || vote3 ==idea2)
```

Now we need to check and compare all the votes to know which idea we will be funding the code block below does that easily.
```js
if(vote1 == idea1 && vote2 == idea1){transfer( funds * 3).to(Proposer1)}
else if(vote1 == idea2 && vote2 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote1 == idea1 && vote3 == idea1){transfer(funds * 3 ).to(Proposer1)}
else if(vote1 == idea2 && vote3 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote2 == idea2 && vote3 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote2 == idea1 && vote3 == idea1){transfer(funds * 3 ).to(Proposer1)}
commit();
```

The result is then sent out on this line of code.
```js
seeOutcome(vote1, vote2, vote3);
```

## See the full Rsh file below

```js
'reach 0.1';


const Persons = {
  informTimeout: Fun([], Null),
  viewIdeas:  Fun([Bytes(10), Bytes(10)], Null),
  voteIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
}

export const main = Reach.App(() => {
const user1 = Participant("user1", {
  ...Persons,
  funds: UInt,
  deadline: UInt,

});
const user2 = Participant("user2", {
  ...Persons,
  accepFunds: Fun([UInt], Null),

});
const user3 = Participant("user3", {
  ...Persons,
  accepFunds: Fun([UInt], Null),
});

const Proposer1 = Participant("Proposer1", {
  proposeIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
});

const Proposer2 = Participant("Proposer2", {
  proposeIdea: Fun([], Bytes(10)),
  seeOutcome: Fun([Bytes(10), Bytes(10), Bytes(10)], Null)
})
init();




const informTimeout = () => {
  each([user1, user2, user3], ()=> {
    interact.informTimeout();
  })
};
const seeOutcome = (fVote, sVote, tVote) => {
  each([user1, user2, user3, Proposer1, Proposer2], ()=> {
    interact.seeOutcome(fVote, sVote, tVote);
  })
};



Proposer1.only(() => {
  const idea1 = declassify(interact.proposeIdea());
});
Proposer1.publish(idea1);

commit();

Proposer2.only(() => {
  const idea2 = declassify(interact.proposeIdea());
})

Proposer2.publish(idea2);

commit();


user1.only(()=> {
  const funds = declassify(interact.funds);
  const deadline = declassify(interact.deadline)
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote1 = declassify(interact.voteIdea());
  assume(vote1 == idea1 || vote1 ==idea2)
  assert(vote1 == idea1 || vote1 ==idea2);
});
  user1.publish(funds, deadline, vote1);
  require(vote1 == idea1 || vote1 ==idea2 );
  commit();
  user1.pay(funds)
  commit();

user2.only(()=> {
  interact.accepFunds(funds);
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote2 = declassify(interact.voteIdea());
  assume(vote2 == idea1 || vote2 ==idea2);
  assert(vote2 == idea1 || vote2 ==idea2);
});
user2.publish(vote2);
require(vote2 == idea1 || vote2 == idea2)
commit();
user2.pay(funds)
  .timeout(relativeTime(deadline), () => closeTo(user1, informTimeout));
  commit();
user2.publish();
commit();


user3.only(()=> {
  interact.accepFunds(funds);
  const ideas = declassify(interact.viewIdeas(idea1, idea2));
  const vote3 = declassify(interact.voteIdea());
  assume(vote3 == idea1 || vote3 == idea2);
  assert(vote3 == idea1 || vote3 == idea2);
});

user3.pay(funds)
  .timeout(relativeTime(deadline), () => closeTo(user1, informTimeout));
  commit();
user3.publish(vote3);
require(vote3 == idea1 || vote3 ==idea2)


if(vote1 == idea1 && vote2 == idea1){transfer( funds * 3).to(Proposer1)}
else if(vote1 == idea2 && vote2 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote1 == idea1 && vote3 == idea1){transfer(funds * 3 ).to(Proposer1)}
else if(vote1 == idea2 && vote3 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote2 == idea2 && vote3 == idea2){transfer(funds * 3 ).to(Proposer2)}
else if(vote2 == idea1 && vote3 == idea1){transfer(funds * 3 ).to(Proposer1)}
commit();
seeOutcome(vote1, vote2, vote3);

  exit();
  });
```

